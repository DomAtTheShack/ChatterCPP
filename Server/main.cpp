#include <iostream>#include <netinet/in.h>#include <sys/socket.h>#include <unistd.h>#include "../Packet.h"#include "User.h"#include <vector>#include <thread>#include <mutex>#define PORT 8081using namespace std;int initServerSocket(int &serverSocket);void addUser(Packet* pkt, int& clientSocket);int acceptConnection(int& clientSocket, const int& serverSocket);int packetSize(int &bufferSize, const int& clientSocket);bool isUserConnected(const std::string& userID);void handleClient(int& clientSocket);void handleOutgoing(int& clientSocket);std::vector<User*> users = {}; // List of users connected to the serverstd::mutex mtx;  // Mutex for synchronizing access to socket operationsstd::vector<Packet*> outGoing = {};std::mutex outGoingMutex;       // Mutex for synchronizing access to outGoingint main(){    int serverSocket;    //Initialize the server socket and check for any port errors    if (initServerSocket(serverSocket) == -1)    {        std::cerr << "Failed to initialize server socket." << std::endl;        return -1;    }    std::cout << "Listening for connections..." << std::endl;    listen(serverSocket, 5); // As stated above the server is now listening for connections to reply to.    std::vector<std::thread> clientThreads; // This list will store all the threads in use by each client.    while (true) // The Main Server Loop will eventually be able to break.    {        int clientSocket;        // Accept a new connection after creating the client socket        acceptConnection(clientSocket, serverSocket);        // Create a new thread to handle this client using a lambda        clientThreads.emplace_back([&clientSocket]() {            handleClient(clientSocket);        });        clientThreads.emplace_back([&clientSocket]() {            handleOutgoing(clientSocket);        });    }    // Wait for all client threads to finish (not reached in this example)    for (auto& thread : clientThreads)    {        if (thread.joinable())        {            thread.join();        }    }    return 0;}/** This method will always be used in a separate thread then the Main loop for each client. *  This will loop indefinitely and will get the packet and the size *  then after getting the user and adding or responding if user already has connected. * @param clientSocket This will be the client socket that the server and client will communicate over. */void handleClient(int& clientSocket){    while (true)    {        int bufferSize = 1024;        // Get the size of the incoming packet        if (packetSize(bufferSize, clientSocket) == -1)        {            std::cerr << "Failed to get packet size or connection closed." << std::endl;            close(clientSocket); // Close the socket if an error occurs            return;  // End the thread for this client        }        char* buffer = new char[bufferSize]; // Dynamically allocate the buffer        // Receive the entire packet with the receiveAll method        if (!Packet::receiveAll(clientSocket, buffer, bufferSize))        {            std::cerr << "Failed to receive complete packet data or connection closed." << std::endl;            close(clientSocket);            delete[] buffer; // Free allocated memory            return;  // End the thread for this client        }        // Creates a new Packet then deserializes the data coming into the packet over the socket        auto* pkt = new Packet();        Packet::deserialize(buffer, bufferSize, pkt); // Deserialize the received data        // This section should remain unchanged, focusing on adding the packet to outGoing        std::lock_guard<std::mutex> lock(mtx);  // Lock mutex for synchronized output        std::cout << "Packet received: " << pkt->getMsg() << std::endl;        // Add the packet to outgoing queue        outGoing.push_back(pkt);        delete[] buffer; // Free the buffer memory    }}void handleOutgoing(int& clientSocket){    while (true) {        std::unique_lock<std::mutex> lock(mtx);        // If there are no packets, wait for new packets to come in        if (outGoing.empty()) {            lock.unlock();  // Unlock before sleep            std::this_thread::sleep_for(std::chrono::seconds(1));  // Sleep to avoid busy-wait            continue;        }        // Process outgoing packets        for (auto it = outGoing.begin(); it != outGoing.end(); ) {            std::cout << "Sending packet to client: " << (*it)->getMsg() << std::endl;            if (Packet::sendPacket(**it, &clientSocket) <= 0) {                std::cerr << "Error: Failed to send packet!" << std::endl;                it++;                continue;            }            std::cout << "Packet sent successfully: " << (*it)->getMsg() << std::endl;            // If packet sent successfully, erase from the queue            delete *it;            it = outGoing.erase(it);        }        lock.unlock();        std::this_thread::sleep_for(std::chrono::seconds(1));  // Avoid busy-waiting    }}/** This will initialize the socket over localhost at the moment and check for any port errors * * @param serverSocket This is the main server socket that the program will use * @return will return 0 if everything went ok or else it will return -1 */int initServerSocket(int &serverSocket){    serverSocket = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serverAddress{};    serverAddress.sin_family = AF_INET;    serverAddress.sin_port = htons(PORT);    serverAddress.sin_addr.s_addr = INADDR_ANY;    if(bind(serverSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress)) != 0)    {        cerr << " ERROR: Failed to Bind Server socket to port " << PORT << endl;        return -1;    }    return 0;}/** This is used to add a user to the user vector * * @param pkt The packet the user send to get the UUID and the username * @param clientSocket the socket the client was using */void addUser(Packet* pkt, int& clientSocket){    users.push_back(new User(&clientSocket, pkt->getUsr(), pkt->getID()));}/** * Accepts a incoming connection to the serverSocket and uses that to init the clientSocket * @param clientSocket The socket to be used with this client * @param serverSocket The socket the main server is communicating over * @return returns 0 on success or -1 if any error has occurred */int acceptConnection(int& clientSocket, const int& serverSocket){    clientSocket = accept(serverSocket, nullptr, nullptr);    if (clientSocket < 0)    {        std::cerr << "Error: Failed to accept client connection!" << std::endl;        return -1;    }    return 0;}/** *  Using the client socket it determines the packet byte size and puts it into the bufferSize parameter * @param bufferSize The int to be stored with the size of the incoming packet * @param clientSocket The client socket to be used to receive the size of the incoming packet * @return returns a 0 on success or -1 on any error */int packetSize(int &bufferSize, const int& clientSocket){    int receivedSize = recv(clientSocket, &bufferSize, sizeof(bufferSize), 0);    if (receivedSize != sizeof(bufferSize) || bufferSize <= 0)    {        std::cerr << "Error: Received incorrect buffer size!" << std::endl;        close(clientSocket);        return -1;    }    return 0;}/** A simple loop to check if the user id given as a parameter is a valid and connected user * * @param userID The UUID to be checked with the users array * @return returns true if the UUID has been found and false if it was not found. */bool isUserConnected(const std::string& userID){    for(User* user: users)    {        if(user->getID() == userID)            return true;    }    return false;}