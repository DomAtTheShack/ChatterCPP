//// Created by dominichann on 8/28/24.//#include <cstring>#include <iostream>#include <netinet/in.h>#include <sys/socket.h>#include <unistd.h>#include <atomic>#include <thread>#include "../Packet.h"#define PORT 8083sockaddr_in initClientSocket(int& clientSocket);void checkForIncomingPackets(int& clientSocket);std::atomic<bool> running(true); // A flag to control the running state of the programint main() {    int clientSocket;    sockaddr_in serverAddress = initClientSocket(clientSocket);    clientSocket = socket(AF_INET, SOCK_STREAM, 0);  // Create a socket    if (clientSocket < 0) {        std::cerr << "Failed to create socket!" << std::endl;        return -1;    }    if (connect(clientSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress)) != 0) {        std::cerr << "Bad network connection to server!" << std::endl;        close(clientSocket);        return -1;    }    std::string user = "user"; // Example user    std::string message;    std::cout << "Enter your username: ";    getline(std::cin, user);    std::cout << "\n";    // Start the thread to check for incoming packets    Packet* recvPkt;    std::thread receiverThread(checkForIncomingPackets, std::ref(clientSocket)); // Use std::ref to pass by reference    receiverThread.detach();  // Detach the thread to run in the background    while (running)    {        std::cout << "Enter your message: ";        getline(std::cin, message);        std::cout << "\n";        // Clear any leftover characters in the input buffer        std::cin.clear();        std::cin.sync();        auto* pkt = new Packet(user, message);        if (Packet::sendPacket(*pkt, &clientSocket) != 0) {            std::cout << "Message sent" << '\n';        } else {            std::cout << "Message not sent" << '\n';        }        delete pkt;    }    // Close socket when done    close(clientSocket);    return 0;}sockaddr_in initClientSocket(int& clientSocket){    clientSocket = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serverAddress;    serverAddress.sin_family = AF_INET;    serverAddress.sin_port = htons(PORT);    serverAddress.sin_addr.s_addr = INADDR_ANY;    return serverAddress;}void checkForIncomingPackets(int& clientSocket) {    Packet pkt;    while (running) {        // Check if a new packet is available and receive it        if (Packet::checkAndReceivePacket(&clientSocket, &pkt)) {            std::cout << "New message received: ID=" << pkt.getID()                      << ", User=" << pkt.getUsr()                      << ", Msg=" << pkt.getMsg() << '\n';        }        // Sleep for 1 second        std::this_thread::sleep_for(std::chrono::seconds(1));    }}